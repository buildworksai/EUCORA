# SPDX-License-Identifier: Apache-2.0
# Copyright (c) 2026 BuildWorks.AI
"""
End-to-end integration tests for deployment flow.

Tests complete deployment lifecycle:
1. Evidence pack generation (P4)
2. Risk assessment (P5.1)
3. CAB workflow with blast-radius gates (P5.2, P5.3)
4. Defense-in-depth security validation (P5.5)
5. Connector orchestration (P6 - Intune + Jamf)
6. Ring-based rollout with promotion gates

These tests verify that all components work together correctly in realistic scenarios.
"""
import pytest
from unittest.mock import Mock, patch, MagicMock
from django.test import TestCase, TransactionTestCase
from django.contrib.auth import get_user_model
from django.utils import timezone
from decimal import Decimal
import uuid

from apps.deployment_intents.models import DeploymentIntent, RingDeployment
from apps.evidence_pack.models import EvidencePack, ArtifactMetadata, SBOMDocument, VulnerabilityScanResult
from apps.risk_assessment.models import RiskAssessment, RiskModelVersion
from apps.cab_workflow.models import CABApprovalRequest, CABApprovalDecision
from apps.incident_management.models import IncidentReport, BlastRadiusClassification

User = get_user_model()


class TestEndToEndDeploymentFlow(TransactionTestCase):
    """
    Test complete end-to-end deployment flow.

    Scenario: Deploy a new Windows application (Acrobat Reader) to production
    through the complete governance pipeline.
    """

    def setUp(self):
        """Setup test data and mock connectors."""
        # Create test users
        self.packaging_engineer = User.objects.create_user(
            username='pkg_engineer',
            email='pkg@example.com',
            password='testpass123'
        )
        self.cab_approver = User.objects.create_user(
            username='cab_approver',
            email='cab@example.com',
            password='testpass123'
        )
        self.publisher = User.objects.create_user(
            username='publisher',
            email='pub@example.com',
            password='testpass123'
        )

        # Create active risk model
        self.risk_model = RiskModelVersion.objects.create(
            version='1.0',
            is_active=True,
            factors={
                'privilege_impact': {'weight': 20},
                'supply_chain_trust': {'weight': 15},
                'exploitability': {'weight': 10},
                'data_access': {'weight': 10},
                'sbom_vulnerability': {'weight': 15},
                'blast_radius': {'weight': 10},
                'operational_complexity': {'weight': 10},
                'history': {'weight': 10},
            },
            thresholds={
                'low': 30,
                'medium': 50,
                'high': 70,
                'critical': 90,
            },
            created_by=self.packaging_engineer
        )

        # Create deployment intent
        self.deployment_intent = DeploymentIntent.objects.create(
            name='Deploy Acrobat Reader DC 2024.001',
            description='Production deployment of Adobe Acrobat Reader DC',
            target_ring=RingDeployment.CANARY,
            target_scope=['BU:Engineering', 'Site:Seattle'],
            correlation_id='DEPLOY-E2E-001',
            created_by=self.packaging_engineer,
            status='PENDING_EVIDENCE'
        )

        self.correlation_id = self.deployment_intent.correlation_id

    def test_complete_deployment_flow_low_risk(self):
        """
        Test complete deployment flow for low-risk application.

        Flow:
        1. Generate evidence pack
        2. Perform risk assessment (score < 50)
        3. Skip CAB approval (low risk)
        4. Deploy to Ring 1 (Canary) via Intune
        5. Validate promotion gates
        6. Promote to Ring 2 (Pilot)
        """
        # Step 1: Generate evidence pack
        evidence_pack = self._generate_evidence_pack(
            artifact_hash='abc123def456',
            sbom_valid=True,
            vuln_scan_pass=True,
            critical_vulns=0,
            high_vulns=0
        )

        self.assertEqual(evidence_pack.deployment_intent, self.deployment_intent)
        self.assertEqual(evidence_pack.status, 'COMPLETE')

        # Step 2: Perform risk assessment
        risk_assessment = self._perform_risk_assessment(
            evidence_pack=evidence_pack,
            privilege_level='user',
            signed=True,
            known_publisher=True,
            blast_radius_scope_size=50
        )

        # Low-risk application (signed, known publisher, user-level, no CVEs)
        self.assertLess(risk_assessment.total_score, 50)
        self.assertEqual(risk_assessment.risk_level, 'LOW')

        # Step 3: Check CAB requirement (should be skipped for low risk)
        cab_required = risk_assessment.total_score > 50
        self.assertFalse(cab_required)

        # Update deployment intent status
        self.deployment_intent.status = 'APPROVED'
        self.deployment_intent.save()

        # Step 4: Deploy to Ring 1 (Canary) via Intune
        with patch('apps.connectors.intune.client.IntuneConnector') as mock_intune:
            intune_connector = mock_intune.return_value
            intune_connector.create_win32_app.return_value = {
                'id': 'intune-app-123',
                'displayName': 'Acrobat Reader DC',
            }
            intune_connector.assign_app_to_group.return_value = {'status': 'success'}

            # Simulate deployment
            app = intune_connector.create_win32_app(
                display_name='Acrobat Reader DC',
                description='PDF reader',
                publisher='Adobe',
                file_name='AcrobatReaderDC.intunewin',
                setup_file_path='setup.exe',
                install_command='setup.exe /silent',
                uninstall_command='setup.exe /uninstall',
                detection_rules=[{'@odata.type': '#microsoft.graph.win32LobAppFileSystemDetection'}],
                correlation_id=self.correlation_id
            )

            # Assign to Canary group
            intune_connector.assign_app_to_group(
                app_id=app['id'],
                group_id='canary-group-123',
                intent='required',
                correlation_id=self.correlation_id
            )

        # Step 5: Validate promotion gates (simulated successful deployment)
        promotion_ready = self._check_promotion_gates(
            install_success_rate=99.5,
            time_to_compliance_hours=12,
            security_incidents=0,
            rollback_validated=True
        )

        self.assertTrue(promotion_ready)

        # Step 6: Promote to Ring 2 (Pilot)
        self.deployment_intent.target_ring = RingDeployment.PILOT
        self.deployment_intent.status = 'IN_PROGRESS'
        self.deployment_intent.save()

        self.assertEqual(self.deployment_intent.target_ring, RingDeployment.PILOT)

    def test_complete_deployment_flow_high_risk_with_cab(self):
        """
        Test complete deployment flow for high-risk application requiring CAB approval.

        Flow:
        1. Generate evidence pack
        2. Perform risk assessment (score > 50)
        3. Submit to CAB and get approval
        4. Deploy to Ring 1 (Canary) via Intune
        5. Validate promotion gates
        6. Submit Ring 2 CAB request
        7. Get approval and promote to Ring 2 (Pilot)
        """
        # Step 1: Generate evidence pack with some security concerns
        evidence_pack = self._generate_evidence_pack(
            artifact_hash='xyz789abc456',
            sbom_valid=True,
            vuln_scan_pass=False,  # Has vulnerabilities but with exception
            critical_vulns=0,
            high_vulns=2  # 2 High vulnerabilities
        )

        # Step 2: Perform risk assessment
        risk_assessment = self._perform_risk_assessment(
            evidence_pack=evidence_pack,
            privilege_level='admin',  # Elevated privileges
            signed=True,
            known_publisher=True,
            blast_radius_scope_size=500  # Larger scope
        )

        # High-risk application (admin privileges, high vulns, large scope)
        self.assertGreater(risk_assessment.total_score, 50)
        self.assertIn(risk_assessment.risk_level, ['MEDIUM', 'HIGH'])

        # Step 3: Submit to CAB
        cab_request = CABApprovalRequest.objects.create(
            deployment_intent=self.deployment_intent,
            risk_assessment=risk_assessment,
            evidence_pack=evidence_pack,
            target_ring=RingDeployment.CANARY,
            requested_by=self.packaging_engineer,
            status='PENDING'
        )

        # CAB approves with conditions
        cab_decision = CABApprovalDecision.objects.create(
            approval_request=cab_request,
            approver=self.cab_approver,
            decision='APPROVED_WITH_CONDITIONS',
            conditions=['Monitor installation failures closely', 'Maintain 24/7 on-call support'],
            justification='Approved with enhanced monitoring for Ring 1 deployment',
            approval_date=timezone.now()
        )

        cab_request.status = 'APPROVED'
        cab_request.approved_at = timezone.now()
        cab_request.save()

        self.assertEqual(cab_request.status, 'APPROVED')
        self.assertEqual(cab_decision.decision, 'APPROVED_WITH_CONDITIONS')

        # Update deployment intent
        self.deployment_intent.status = 'APPROVED'
        self.deployment_intent.save()

        # Step 4: Deploy to Ring 1 (Canary) via Intune
        with patch('apps.connectors.intune.client.IntuneConnector') as mock_intune:
            intune_connector = mock_intune.return_value
            intune_connector.create_win32_app.return_value = {
                'id': 'intune-app-456',
                'displayName': 'Enterprise Security Tool',
            }
            intune_connector.assign_app_to_group.return_value = {'status': 'success'}

            # Deploy
            app = intune_connector.create_win32_app(
                display_name='Enterprise Security Tool',
                description='Security monitoring tool',
                publisher='Security Vendor',
                file_name='SecurityTool.intunewin',
                setup_file_path='setup.exe',
                install_command='setup.exe /silent /admin',
                uninstall_command='setup.exe /uninstall',
                detection_rules=[{'@odata.type': '#microsoft.graph.win32LobAppFileSystemDetection'}],
                correlation_id=self.correlation_id
            )

            intune_connector.assign_app_to_group(
                app_id=app['id'],
                group_id='canary-group-456',
                intent='required',
                correlation_id=self.correlation_id
            )

        # Step 5: Validate promotion gates (successful with monitoring)
        promotion_ready = self._check_promotion_gates(
            install_success_rate=98.0,  # Meets 97% threshold
            time_to_compliance_hours=20,  # Within 24h threshold
            security_incidents=0,
            rollback_validated=True
        )

        self.assertTrue(promotion_ready)

        # Step 6: Submit Ring 2 CAB request
        cab_request_ring2 = CABApprovalRequest.objects.create(
            deployment_intent=self.deployment_intent,
            risk_assessment=risk_assessment,
            evidence_pack=evidence_pack,
            target_ring=RingDeployment.PILOT,
            requested_by=self.publisher,
            status='PENDING'
        )

        # CAB approves Ring 2
        cab_decision_ring2 = CABApprovalDecision.objects.create(
            approval_request=cab_request_ring2,
            approver=self.cab_approver,
            decision='APPROVED',
            justification='Ring 1 deployment successful, approve Ring 2',
            approval_date=timezone.now()
        )

        cab_request_ring2.status = 'APPROVED'
        cab_request_ring2.approved_at = timezone.now()
        cab_request_ring2.save()

        # Step 7: Promote to Ring 2 (Pilot)
        self.deployment_intent.target_ring = RingDeployment.PILOT
        self.deployment_intent.status = 'IN_PROGRESS'
        self.deployment_intent.save()

        self.assertEqual(self.deployment_intent.target_ring, RingDeployment.PILOT)

    def test_deployment_flow_with_incident_and_blast_radius(self):
        """
        Test deployment flow with incident reporting and blast radius classification.

        Flow:
        1. Deploy application to Ring 1
        2. Incident occurs (installation failures)
        3. Classify blast radius
        4. Halt promotion to Ring 2
        5. Implement fix
        6. Re-validate and resume
        """
        # Step 1: Initial deployment (simplified)
        evidence_pack = self._generate_evidence_pack(
            artifact_hash='incident123',
            sbom_valid=True,
            vuln_scan_pass=True,
            critical_vulns=0,
            high_vulns=0
        )

        risk_assessment = self._perform_risk_assessment(
            evidence_pack=evidence_pack,
            privilege_level='user',
            signed=True,
            known_publisher=True,
            blast_radius_scope_size=100
        )

        self.deployment_intent.status = 'IN_PROGRESS'
        self.deployment_intent.save()

        # Step 2: Incident occurs - high installation failure rate
        incident = IncidentReport.objects.create(
            deployment_intent=self.deployment_intent,
            incident_type='INSTALLATION_FAILURE',
            severity='HIGH',
            description='Installation failures on 15% of Ring 1 devices',
            affected_devices=15,
            reported_by=self.publisher,
            correlation_id=self.correlation_id
        )

        # Step 3: Classify blast radius
        blast_radius = BlastRadiusClassification.objects.create(
            deployment_intent=self.deployment_intent,
            incident_report=incident,
            classification='BUSINESS_CRITICAL',
            affected_scope=['BU:Engineering'],
            affected_device_count=15,
            potential_device_count=100,
            justification='Installation failures affecting critical engineering tools',
            classified_by=self.cab_approver
        )

        self.assertEqual(blast_radius.classification, 'BUSINESS_CRITICAL')
        self.assertEqual(incident.severity, 'HIGH')

        # Step 4: Halt promotion
        promotion_ready = self._check_promotion_gates(
            install_success_rate=85.0,  # Below 97% threshold
            time_to_compliance_hours=24,
            security_incidents=1,
            rollback_validated=True
        )

        self.assertFalse(promotion_ready)

        # Step 5: Resolve incident
        incident.status = 'RESOLVED'
        incident.resolution_notes = 'Fixed installation script, re-deployed to Ring 1'
        incident.resolved_at = timezone.now()
        incident.resolved_by = self.packaging_engineer
        incident.save()

        # Step 6: Re-validate and resume
        promotion_ready_after_fix = self._check_promotion_gates(
            install_success_rate=99.0,  # Fixed
            time_to_compliance_hours=18,
            security_incidents=0,  # Resolved
            rollback_validated=True
        )

        self.assertTrue(promotion_ready_after_fix)

    def test_multi_platform_deployment_intune_and_jamf(self):
        """
        Test multi-platform deployment orchestrating both Intune and Jamf.

        Scenario: Deploy same application to both Windows (Intune) and macOS (Jamf).
        """
        # Generate evidence pack
        evidence_pack = self._generate_evidence_pack(
            artifact_hash='multiplatform123',
            sbom_valid=True,
            vuln_scan_pass=True,
            critical_vulns=0,
            high_vulns=0
        )

        risk_assessment = self._perform_risk_assessment(
            evidence_pack=evidence_pack,
            privilege_level='user',
            signed=True,
            known_publisher=True,
            blast_radius_scope_size=200
        )

        # Deploy to Windows via Intune
        with patch('apps.connectors.intune.client.IntuneConnector') as mock_intune:
            intune_connector = mock_intune.return_value
            intune_connector.create_win32_app.return_value = {
                'id': 'intune-app-789',
                'displayName': 'CrossPlatform App Windows',
            }
            intune_connector.assign_app_to_group.return_value = {'status': 'success'}
            intune_connector.get_app_install_status.return_value = [
                {'deviceName': 'WIN-001', 'installState': 'installed'},
                {'deviceName': 'WIN-002', 'installState': 'installed'},
            ]

            # Create and assign Windows app
            win_app = intune_connector.create_win32_app(
                display_name='CrossPlatform App Windows',
                description='Multi-platform app',
                publisher='Vendor',
                file_name='App.intunewin',
                setup_file_path='setup.exe',
                install_command='setup.exe /s',
                uninstall_command='setup.exe /u',
                detection_rules=[{'@odata.type': '#microsoft.graph.win32LobAppFileSystemDetection'}],
                correlation_id=self.correlation_id
            )

            intune_connector.assign_app_to_group(
                app_id=win_app['id'],
                group_id='windows-group',
                intent='required',
                correlation_id=self.correlation_id
            )

            # Check status
            win_status = intune_connector.get_app_install_status(
                app_id=win_app['id'],
                correlation_id=self.correlation_id
            )

            self.assertEqual(len(win_status), 2)
            self.assertTrue(all(s['installState'] == 'installed' for s in win_status))

        # Deploy to macOS via Jamf
        with patch('apps.connectors.jamf.client.JamfConnector') as mock_jamf:
            jamf_connector = mock_jamf.return_value
            jamf_connector.create_package.return_value = {
                'id': 'jamf-pkg-789',
                'packageName': 'CrossPlatform App macOS',
            }
            jamf_connector.create_policy.return_value = {
                'id': '456',
                'name': 'Deploy CrossPlatform App',
            }
            jamf_connector.get_policy_logs.return_value = {
                'results': [
                    {'computerName': 'MAC-001', 'status': 'Completed'},
                    {'computerName': 'MAC-002', 'status': 'Completed'},
                ]
            }

            # Create package
            mac_pkg = jamf_connector.create_package(
                package_name='CrossPlatform App macOS',
                file_name='App-1.0.pkg',
                category='Productivity',
                correlation_id=self.correlation_id
            )

            # Create policy
            mac_policy = jamf_connector.create_policy(
                policy_name='Deploy CrossPlatform App',
                package_id=mac_pkg['id'],
                scope={'computerGroups': ['Engineering']},
                enabled=True,
                frequency='Once per computer',
                correlation_id=self.correlation_id
            )

            # Check policy logs
            mac_logs = jamf_connector.get_policy_logs(
                policy_id=mac_policy['id'],
                correlation_id=self.correlation_id
            )

            self.assertEqual(len(mac_logs['results']), 2)
            self.assertTrue(all(log['status'] == 'Completed' for log in mac_logs['results']))

        # Both platforms deployed successfully
        self.assertEqual(win_app['id'], 'intune-app-789')
        self.assertEqual(mac_pkg['id'], 'jamf-pkg-789')

    # Helper methods

    def _generate_evidence_pack(
        self,
        artifact_hash: str,
        sbom_valid: bool,
        vuln_scan_pass: bool,
        critical_vulns: int,
        high_vulns: int
    ) -> EvidencePack:
        """Generate complete evidence pack."""
        evidence_pack = EvidencePack.objects.create(
            deployment_intent=self.deployment_intent,
            status='COMPLETE',
            generated_by=self.packaging_engineer,
            correlation_id=self.correlation_id
        )

        # Artifact metadata
        ArtifactMetadata.objects.create(
            evidence_pack=evidence_pack,
            artifact_name='app_package.zip',
            artifact_hash_sha256=artifact_hash,
            artifact_size_bytes=1024000,
            signing_status='SIGNED' if sbom_valid else 'UNSIGNED',
            signing_certificate_thumbprint='ABCD1234' if sbom_valid else None,
            signing_timestamp=timezone.now() if sbom_valid else None
        )

        # SBOM
        SBOMDocument.objects.create(
            evidence_pack=evidence_pack,
            format='SPDX',
            version='2.3',
            document_hash='sbom123',
            component_count=50,
            license_info={'licenses': ['MIT', 'Apache-2.0']},
            supplier_info={'supplier': 'Trusted Vendor'}
        )

        # Vulnerability scan
        VulnerabilityScanResult.objects.create(
            evidence_pack=evidence_pack,
            scanner_name='Trivy',
            scanner_version='0.48.0',
            scan_timestamp=timezone.now(),
            critical_count=critical_vulns,
            high_count=high_vulns,
            medium_count=0,
            low_count=0,
            scan_pass=vuln_scan_pass,
            policy_decision='PASS' if vuln_scan_pass else 'EXCEPTION_APPROVED',
            exception_justification=None if vuln_scan_pass else 'Compensating controls in place'
        )

        return evidence_pack

    def _perform_risk_assessment(
        self,
        evidence_pack: EvidencePack,
        privilege_level: str,
        signed: bool,
        known_publisher: bool,
        blast_radius_scope_size: int
    ) -> RiskAssessment:
        """Perform risk assessment."""
        # Calculate normalized factors
        privilege_score = 1.0 if privilege_level == 'admin' else 0.2
        supply_chain_score = 0.1 if (signed and known_publisher) else 0.4
        sbom_vuln_score = (
            evidence_pack.vulnerability_scan.critical_count * 0.5 +
            evidence_pack.vulnerability_scan.high_count * 0.3
        ) / 10.0  # Normalize
        blast_radius_score = min(blast_radius_scope_size / 1000.0, 1.0)

        # Calculate total score
        factors = self.risk_model.factors
        total_score = (
            privilege_score * factors['privilege_impact']['weight'] +
            supply_chain_score * factors['supply_chain_trust']['weight'] +
            sbom_vuln_score * factors['sbom_vulnerability']['weight'] +
            blast_radius_score * factors['blast_radius']['weight'] +
            0.2 * factors['exploitability']['weight'] +
            0.1 * factors['data_access']['weight'] +
            0.2 * factors['operational_complexity']['weight'] +
            0.1 * factors['history']['weight']
        )

        # Determine risk level
        if total_score < 30:
            risk_level = 'LOW'
        elif total_score < 50:
            risk_level = 'MEDIUM'
        elif total_score < 70:
            risk_level = 'HIGH'
        else:
            risk_level = 'CRITICAL'

        risk_assessment = RiskAssessment.objects.create(
            deployment_intent=self.deployment_intent,
            evidence_pack=evidence_pack,
            risk_model_version=self.risk_model,
            total_score=Decimal(str(total_score)),
            risk_level=risk_level,
            factor_scores={
                'privilege_impact': privilege_score,
                'supply_chain_trust': supply_chain_score,
                'sbom_vulnerability': sbom_vuln_score,
                'blast_radius': blast_radius_score,
            },
            assessed_by=self.packaging_engineer
        )

        return risk_assessment

    def _check_promotion_gates(
        self,
        install_success_rate: float,
        time_to_compliance_hours: int,
        security_incidents: int,
        rollback_validated: bool
    ) -> bool:
        """Check promotion gate criteria."""
        # Ring 1 (Canary) promotion gates
        success_rate_threshold = 97.0  # 97% minimum
        time_threshold_hours = 24  # 24 hours maximum

        gates_passed = (
            install_success_rate >= success_rate_threshold and
            time_to_compliance_hours <= time_threshold_hours and
            security_incidents == 0 and
            rollback_validated
        )

        return gates_passed
