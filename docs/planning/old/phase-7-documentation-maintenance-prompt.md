# Phase 7: Documentation & Maintenance - Implementation Prompt

**Version**: 1.0
**Date**: 2026-01-04
**Target Duration**: 2 weeks
**Dependencies**: All previous phases (1-6)

---

## Task Overview

Implement documentation generation scripts, maintenance automation (log rotation, cleanup, health checks), scheduled tasks (daily/weekly/monthly), and operational dashboards. This phase ensures the platform is self-documenting, self-maintaining, and provides visibility to stakeholders.

**Success Criteria**:
- Auto-generated documentation for all scripts (from comment-based help)
- Maintenance scripts run on schedule (daily health checks, weekly log rotation, monthly audits)
- Operational dashboards display control plane health, deployment metrics, ring status
- Runbooks automatically updated with current configuration
- Technical debt tracked and prioritized

---

## Mandatory Guardrails

### Architecture Alignment
- ✅ **Thin Control Plane**: Documentation scripts read-only, never modify control plane state
- ✅ **Separation of Duties**: Maintenance scripts enforce RBAC, no privilege escalation
- ✅ **Deterministic**: Scheduled tasks produce consistent results
- ✅ **Evidence-First**: All maintenance operations logged with correlation IDs
- ✅ **Offline-First**: Documentation generation works without internet access

### Quality Standards
- ✅ **PSScriptAnalyzer**: ZERO errors, ZERO warnings
- ✅ **Pester Tests**: ≥90% coverage per script
- ✅ **Idempotency**: All maintenance operations safe to retry
- ✅ **Non-Disruptive**: Maintenance never interrupts deployments
- ✅ **Error Handling**: Failed maintenance tasks alert Platform Admins

### Security Requirements
- ✅ **Read-Only Documentation**: Generated docs don't expose secrets
- ✅ **Audit Trail**: All maintenance operations logged to SIEM
- ✅ **Least Privilege**: Cleanup scripts scoped to temporary directories only

---

## Scope: Documentation Generation (scripts/maintenance/documentation/)

### 1. New-ScriptDocumentation.ps1

```powershell
<#
.SYNOPSIS
    Generate markdown documentation from PowerShell comment-based help.
.DESCRIPTION
    Parses all .ps1 files, extracts comment-based help, generates markdown reference docs.
.PARAMETER SourcePath
    Path to scripts directory.
.PARAMETER OutputPath
    Path to output markdown files.
.EXAMPLE
    New-ScriptDocumentation -SourcePath "./scripts" -OutputPath "./docs/reference"
#>
function New-ScriptDocumentation {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [ValidateScript({ Test-Path $_ })]
        [string]$SourcePath,

        [Parameter(Mandatory = $true)]
        [string]$OutputPath
    )

    $docCid = Get-CorrelationId -Prefix "doc-gen"

    Write-StructuredLog -Level "Info" -Message "Starting documentation generation" -CorrelationId $docCid

    # Create output directory
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null

    # Get all PowerShell scripts
    $scripts = Get-ChildItem -Path $SourcePath -Recurse -Filter "*.ps1" | Where-Object { $_.Name -notlike "*.Tests.ps1" }

    foreach ($script in $scripts) {
        # Extract comment-based help
        $help = Get-Help $script.FullName -Full

        if (-not $help.Synopsis) {
            Write-StructuredLog -Level "Warning" -Message "No help found for script" -CorrelationId $docCid -Metadata @{ Script = $script.Name }
            continue
        }

        # Generate markdown
        $markdown = @"
# $($help.Name)

## Synopsis
$($help.Synopsis)

## Description
$($help.Description.Text)

## Parameters
$(foreach ($param in $help.Parameters.Parameter) {
"### $($param.Name)
- **Type**: $($param.Type.Name)
- **Required**: $($param.Required)
- **Description**: $($param.Description.Text)
"
})

## Examples
$(foreach ($example in $help.Examples.Example) {
"### $($example.Title)
``````powershell
$($example.Code)
``````
$($example.Remarks.Text)
"
})

## Notes
- **File**: $($script.FullName)
- **Last Modified**: $($script.LastWriteTime.ToString("yyyy-MM-dd HH:mm:ss"))

---
*Generated by New-ScriptDocumentation on $(Get-Date -Format "yyyy-MM-dd")*
"@

        # Write markdown file
        $outputFile = Join-Path $OutputPath "$($script.BaseName).md"
        $markdown | Out-File $outputFile -Encoding UTF8

        Write-StructuredLog -Level "Info" -Message "Documentation generated" -CorrelationId $docCid -Metadata @{ Script = $script.Name; Output = $outputFile }
    }

    Write-StructuredLog -Level "Info" -Message "Documentation generation completed" -CorrelationId $docCid -Metadata @{ TotalScripts = $scripts.Count }
}
```

**Pester Tests Required**:
- Markdown generated for script with help
- Warning logged for script without help
- Output directory created if not exists
- Markdown format valid

---

### 2. New-ConfigurationDiagram.ps1

```powershell
<#
.SYNOPSIS
    Generate architecture diagram from configuration.
.DESCRIPTION
    Creates Mermaid diagram showing control plane components, connectors, rings.
.PARAMETER OutputPath
    Path to output diagram markdown.
.EXAMPLE
    New-ConfigurationDiagram -OutputPath "./docs/diagrams/architecture.md"
#>
function New-ConfigurationDiagram {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$OutputPath
    )

    # Generate Mermaid diagram
    $diagram = @"
# Architecture Diagram

``````mermaid
graph TD
    CLI[CLI: dapctl] --> API[API Gateway]
    API --> PE[Policy Engine]
    API --> ORCH[Orchestrator]
    API --> CAB[CAB Workflow]
    API --> ES[Evidence Store]
    API --> EVS[Event Store]

    PE --> ORCH
    CAB --> ORCH

    ORCH --> INTUNE[Intune Connector]
    ORCH --> JAMF[Jamf Connector]
    ORCH --> SCCM[SCCM Connector]
    ORCH --> LAND[Landscape Connector]
    ORCH --> ANS[Ansible Connector]

    INTUNE --> R1[Ring: Lab]
    INTUNE --> R2[Ring: Canary]
    INTUNE --> R3[Ring: Pilot]
    INTUNE --> R4[Ring: Department]
    INTUNE --> R5[Ring: Global]

    JAMF --> R1
    SCCM --> R1
    LAND --> R1
    ANS --> R1
``````

---
*Generated on $(Get-Date -Format "yyyy-MM-dd")*
"@

    $diagram | Out-File $OutputPath -Encoding UTF8
    Write-Host "Architecture diagram generated: $OutputPath"
}
```

**Pester Tests Required**:
- Diagram file created
- Mermaid syntax valid

---

## Scope: Maintenance Automation (scripts/maintenance/)

### 1. Invoke-HealthCheck.ps1

```powershell
<#
.SYNOPSIS
    Perform system health check.
.DESCRIPTION
    Checks control plane API, connectors, event store, evidence store health. Runs daily.
.EXAMPLE
    Invoke-HealthCheck
#>
function Invoke-HealthCheck {
    [CmdletBinding()]
    param()

    $healthCid = Get-CorrelationId -Prefix "health"

    Write-StructuredLog -Level "Info" -Message "Starting health check" -CorrelationId $healthCid

    $healthReport = @{
        Timestamp = (Get-Date -Format "o")
        CorrelationId = $healthCid
        ControlPlaneHealth = $null
        ConnectorHealth = @{}
        EventStoreHealth = $null
        EvidenceStoreHealth = $null
        OverallStatus = "Healthy"
    }

    # 1. Control Plane API
    try {
        $apiResponse = Invoke-RestMethod -Uri "$($global:Config.ControlPlaneApiUri)/health" -Method GET -TimeoutSec 10
        $healthReport.ControlPlaneHealth = @{ Status = "Healthy"; Latency = $apiResponse.latency }
    } catch {
        $healthReport.ControlPlaneHealth = @{ Status = "Unhealthy"; Error = $_.Exception.Message }
        $healthReport.OverallStatus = "Degraded"
    }

    # 2. Connectors
    foreach ($connector in @("Intune", "Jamf", "SCCM", "Landscape", "Ansible")) {
        try {
            $connectorHealth = Test-ConnectorHealth -Connector $connector
            $healthReport.ConnectorHealth[$connector] = $connectorHealth
            if ($connectorHealth.Status -ne "Healthy") {
                $healthReport.OverallStatus = "Degraded"
            }
        } catch {
            $healthReport.ConnectorHealth[$connector] = @{ Status = "Unhealthy"; Error = $_.Exception.Message }
            $healthReport.OverallStatus = "Degraded"
        }
    }

    # 3. Event Store
    try {
        $eventCount = (Invoke-RestMethod -Uri "$($global:Config.EventStoreUri)/api/events/count" -Method GET).count
        $healthReport.EventStoreHealth = @{ Status = "Healthy"; EventCount = $eventCount }
    } catch {
        $healthReport.EventStoreHealth = @{ Status = "Unhealthy"; Error = $_.Exception.Message }
        $healthReport.OverallStatus = "Degraded"
    }

    # 4. Evidence Store
    try {
        $evidenceCount = (Invoke-RestMethod -Uri "$($global:Config.ControlPlaneApiUri)/api/evidence-packs/count" -Method GET).count
        $healthReport.EvidenceStoreHealth = @{ Status = "Healthy"; EvidencePackCount = $evidenceCount }
    } catch {
        $healthReport.EvidenceStoreHealth = @{ Status = "Unhealthy"; Error = $_.Exception.Message }
        $healthReport.OverallStatus = "Degraded"
    }

    # 5. Alert if unhealthy
    if ($healthReport.OverallStatus -ne "Healthy") {
        Write-StructuredLog -Level "Error" -Message "Health check failed" -CorrelationId $healthCid -Metadata $healthReport
        Send-AlertEmail -Subject "Control Plane Health Degraded" -Body ($healthReport | ConvertTo-Json -Depth 5)
    } else {
        Write-StructuredLog -Level "Info" -Message "Health check passed" -CorrelationId $healthCid
    }

    # 6. Send to SIEM
    Send-SIEMEvent -Event $healthReport

    return $healthReport
}
```

**Pester Tests Required**:
- Healthy system returns "Healthy" status
- Unhealthy connector triggers "Degraded" status
- Alert sent when degraded

---

### 2. Invoke-LogRotation.ps1

```powershell
<#
.SYNOPSIS
    Rotate and archive log files.
.DESCRIPTION
    Archives logs older than 7 days, compresses, uploads to blob storage. Runs weekly.
.EXAMPLE
    Invoke-LogRotation
#>
function Invoke-LogRotation {
    [CmdletBinding()]
    param()

    $rotationCid = Get-CorrelationId -Prefix "log-rotation"

    Write-StructuredLog -Level "Info" -Message "Starting log rotation" -CorrelationId $rotationCid

    $logPath = Get-ConfigValue -Key "LogFilePath"
    $archivePath = "$logPath/archive"
    New-Item -ItemType Directory -Path $archivePath -Force | Out-Null

    # Get logs older than 7 days
    $oldLogs = Get-ChildItem -Path $logPath -Filter "*.log" | Where-Object { $_.LastWriteTime -lt (Get-Date).AddDays(-7) }

    foreach ($log in $oldLogs) {
        # Compress log
        $zipPath = "$archivePath/$($log.BaseName)-$(Get-Date -Format 'yyyy-MM-dd').zip"
        Compress-Archive -Path $log.FullName -DestinationPath $zipPath

        # Upload to blob storage (for long-term retention per SIEM integration 2-7 years)
        $blobUri = "$($global:Config.ArchiveBlobUri)/$($log.BaseName)-$(Get-Date -Format 'yyyy-MM-dd').zip"
        # Upload to Azure Blob Storage with WORM policy
        # az storage blob upload --account-name <storage> --container-name logs --file $zipPath --name $log.BaseName

        # Delete original log
        Remove-Item $log.FullName

        Write-StructuredLog -Level "Info" -Message "Log rotated" -CorrelationId $rotationCid -Metadata @{ Log = $log.Name; Archive = $zipPath }
    }

    Write-StructuredLog -Level "Info" -Message "Log rotation completed" -CorrelationId $rotationCid -Metadata @{ RotatedCount = $oldLogs.Count }
}
```

**Pester Tests Required**:
- Logs older than 7 days archived
- Logs compressed
- Original logs deleted
- Recent logs not touched

---

### 3. Invoke-CleanupTempFiles.ps1

```powershell
<#
.SYNOPSIS
    Clean up temporary files from packaging pipeline.
.DESCRIPTION
    Deletes temp files older than 24 hours. Runs daily.
.EXAMPLE
    Invoke-CleanupTempFiles
#>
function Invoke-CleanupTempFiles {
    [CmdletBinding()]
    param()

    $cleanupCid = Get-CorrelationId -Prefix "cleanup"

    Write-StructuredLog -Level "Info" -Message "Starting temp file cleanup" -CorrelationId $cleanupCid

    # Clean up packaging temp files
    $tempPaths = @(
        "$env:TEMP/repackaged-*",
        "$env:TEMP/sbom-*",
        "$env:TEMP/scan-*",
        "$env:TEMP/provenance-*",
        "$env:TEMP/evidence-pack-*"
    )

    $deletedCount = 0
    foreach ($pattern in $tempPaths) {
        $files = Get-ChildItem -Path $pattern -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -lt (Get-Date).AddHours(-24) }
        foreach ($file in $files) {
            Remove-Item $file.FullName -Recurse -Force
            $deletedCount++
        }
    }

    Write-StructuredLog -Level "Info" -Message "Temp file cleanup completed" -CorrelationId $cleanupCid -Metadata @{ DeletedCount = $deletedCount }
}
```

**Pester Tests Required**:
- Files older than 24 hours deleted
- Recent files not touched
- Handles missing directories gracefully

---

## Scope: Scheduled Tasks

### 1. Register-MaintenanceTasks.ps1

```powershell
<#
.SYNOPSIS
    Register scheduled tasks for maintenance automation.
.DESCRIPTION
    Creates Windows Task Scheduler tasks for daily/weekly/monthly maintenance.
.EXAMPLE
    Register-MaintenanceTasks
#>
function Register-MaintenanceTasks {
    [CmdletBinding()]
    param()

    # Daily: Health Check (6 AM)
    $healthCheckAction = New-ScheduledTaskAction -Execute "pwsh.exe" -Argument "-File scripts/maintenance/Invoke-HealthCheck.ps1"
    $healthCheckTrigger = New-ScheduledTaskTrigger -Daily -At "06:00"
    Register-ScheduledTask -TaskName "ControlPlane-HealthCheck" -Action $healthCheckAction -Trigger $healthCheckTrigger -User "SYSTEM" -RunLevel Highest

    # Daily: Cleanup Temp Files (2 AM)
    $cleanupAction = New-ScheduledTaskAction -Execute "pwsh.exe" -Argument "-File scripts/maintenance/Invoke-CleanupTempFiles.ps1"
    $cleanupTrigger = New-ScheduledTaskTrigger -Daily -At "02:00"
    Register-ScheduledTask -TaskName "ControlPlane-Cleanup" -Action $cleanupAction -Trigger $cleanupTrigger -User "SYSTEM" -RunLevel Highest

    # Weekly: Log Rotation (Sunday 3 AM)
    $logRotationAction = New-ScheduledTaskAction -Execute "pwsh.exe" -Argument "-File scripts/maintenance/Invoke-LogRotation.ps1"
    $logRotationTrigger = New-ScheduledTaskTrigger -Weekly -DaysOfWeek Sunday -At "03:00"
    Register-ScheduledTask -TaskName "ControlPlane-LogRotation" -Action $logRotationAction -Trigger $logRotationTrigger -User "SYSTEM" -RunLevel Highest

    # Monthly: Audit Report (1st of month, 8 AM)
    $auditAction = New-ScheduledTaskAction -Execute "pwsh.exe" -Argument "-File scripts/maintenance/New-MonthlyAuditReport.ps1"
    $auditTrigger = New-ScheduledTaskTrigger -Weekly -WeeksInterval 4 -DaysOfWeek Monday -At "08:00"
    Register-ScheduledTask -TaskName "ControlPlane-AuditReport" -Action $auditAction -Trigger $auditTrigger -User "SYSTEM" -RunLevel Highest

    Write-Host "Maintenance tasks registered successfully."
}
```

**Pester Tests Required**:
- All 4 tasks registered
- Triggers set correctly
- Tasks run as SYSTEM

---

## Scope: Operational Dashboards

### 1. New-OperationalDashboard.ps1

```powershell
<#
.SYNOPSIS
    Generate operational dashboard HTML.
.DESCRIPTION
    Creates dashboard showing control plane health, deployment metrics, ring status.
.PARAMETER OutputPath
    Path to output HTML file.
.EXAMPLE
    New-OperationalDashboard -OutputPath "./dashboards/index.html"
#>
function New-OperationalDashboard {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$OutputPath
    )

    # Collect metrics
    $healthReport = Invoke-HealthCheck
    $deploymentMetrics = Get-DeploymentMetrics -Days 30
    $ringStatus = Get-RingStatus

    # Generate HTML
    $html = @"
<!DOCTYPE html>
<html>
<head>
    <title>Control Plane Dashboard</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .status-healthy { color: green; font-weight: bold; }
        .status-degraded { color: orange; font-weight: bold; }
        .status-unhealthy { color: red; font-weight: bold; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #4CAF50; color: white; }
    </style>
</head>
<body>
    <h1>Control Plane Operational Dashboard</h1>
    <p>Last Updated: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")</p>

    <h2>System Health</h2>
    <p>Overall Status: <span class="status-$($healthReport.OverallStatus.ToLower())">$($healthReport.OverallStatus)</span></p>

    <h3>Component Health</h3>
    <table>
        <tr><th>Component</th><th>Status</th><th>Details</th></tr>
        <tr><td>Control Plane API</td><td>$($healthReport.ControlPlaneHealth.Status)</td><td>Latency: $($healthReport.ControlPlaneHealth.Latency)ms</td></tr>
        $(foreach ($connector in $healthReport.ConnectorHealth.Keys) {
            "<tr><td>$connector Connector</td><td>$($healthReport.ConnectorHealth[$connector].Status)</td><td></td></tr>"
        })
        <tr><td>Event Store</td><td>$($healthReport.EventStoreHealth.Status)</td><td>Events: $($healthReport.EventStoreHealth.EventCount)</td></tr>
        <tr><td>Evidence Store</td><td>$($healthReport.EvidenceStoreHealth.Status)</td><td>Packs: $($healthReport.EvidenceStoreHealth.EvidencePackCount)</td></tr>
    </table>

    <h2>Deployment Metrics (Last 30 Days)</h2>
    <table>
        <tr><th>Metric</th><th>Value</th></tr>
        <tr><td>Total Deployments</td><td>$($deploymentMetrics.TotalDeployments)</td></tr>
        <tr><td>Successful</td><td>$($deploymentMetrics.Successful)</td></tr>
        <tr><td>Failed</td><td>$($deploymentMetrics.Failed)</td></tr>
        <tr><td>Rolled Back</td><td>$($deploymentMetrics.RolledBack)</td></tr>
        <tr><td>Success Rate</td><td>$($deploymentMetrics.SuccessRate)%</td></tr>
    </table>

    <h2>Ring Status</h2>
    <table>
        <tr><th>Ring</th><th>Active Deployments</th><th>Success Rate</th></tr>
        $(foreach ($ring in $ringStatus) {
            "<tr><td>$($ring.Name)</td><td>$($ring.ActiveDeployments)</td><td>$($ring.SuccessRate)%</td></tr>"
        })
    </table>
</body>
</html>
"@

    $html | Out-File $OutputPath -Encoding UTF8
    Write-Host "Dashboard generated: $OutputPath"
}
```

**Helper Functions**:
- `Get-DeploymentMetrics`: Query Event Store for deployment stats
- `Get-RingStatus`: Query active deployments per ring

**Pester Tests Required**:
- HTML file created
- Metrics populated
- HTML valid

---

## Scope: Runbook Automation

### 1. Update-Runbooks.ps1

```powershell
<#
.SYNOPSIS
    Update runbooks with current configuration.
.DESCRIPTION
    Replaces placeholders in runbooks with actual config values (URIs, retention policies, etc.).
.EXAMPLE
    Update-Runbooks
#>
function Update-Runbooks {
    [CmdletBinding()]
    param()

    $runbookPath = "./docs/runbooks"
    $runbooks = Get-ChildItem -Path $runbookPath -Filter "*.md"

    foreach ($runbook in $runbooks) {
        $content = Get-Content $runbook.FullName -Raw

        # Replace placeholders with actual values
        $content = $content -replace '\{\{VaultUri\}\}', (Get-ConfigValue -Key "VaultUri")
        $content = $content -replace '\{\{ControlPlaneApiUri\}\}', (Get-ConfigValue -Key "ControlPlaneApiUri")
        $content = $content -replace '\{\{EventStoreUri\}\}', (Get-ConfigValue -Key "EventStoreUri")

        # Write updated content
        $content | Out-File $runbook.FullName -Encoding UTF8

        Write-Host "Runbook updated: $($runbook.Name)"
    }
}
```

**Pester Tests Required**:
- Placeholders replaced correctly
- Runbooks remain markdown-valid

---

## Quality Checklist

### Per Script
- [ ] PSScriptAnalyzer ZERO errors/warnings
- [ ] Pester tests ≥90% coverage
- [ ] All operations idempotent
- [ ] Non-disruptive (doesn't interrupt deployments)
- [ ] All operations logged

### Scheduled Tasks
- [ ] Daily health checks registered
- [ ] Weekly log rotation registered
- [ ] Monthly audit reports registered
- [ ] All tasks run as SYSTEM with least privilege

### Documentation
- [ ] Auto-generated docs complete
- [ ] Architecture diagrams current
- [ ] Operational dashboards functional
- [ ] Runbooks updated with config

---

## Emergency Stop Conditions

**STOP IMMEDIATELY if**:
1. Cleanup scripts delete non-temporary files
2. Health checks fail consistently (>24 hours)
3. Scheduled tasks fail to run
4. Documentation exposes secrets or credentials
5. Maintenance operations interrupt active deployments

**Escalate to human if**:
- Dashboard shows "Degraded" status for >4 hours
- Multiple connectors unhealthy simultaneously
- Log rotation fills disk space

---

## Delivery Checklist

- [ ] All documentation scripts implemented
- [ ] All maintenance scripts implemented
- [ ] Scheduled tasks registered
- [ ] Operational dashboard deployed
- [ ] Runbooks auto-updated
- [ ] PSScriptAnalyzer: 0 errors, 0 warnings
- [ ] Pester tests: ≥90% coverage
- [ ] README with maintenance procedures

---

## Related Documentation

- [.agents/rules/12-documentation-rules.md](../../.agents/rules/12-documentation-rules.md)
- [docs/runbooks/incident-response.md](../../runbooks/incident-response.md)
- [docs/runbooks/rollback-execution.md](../../runbooks/rollback-execution.md)
- [docs/runbooks/cab-submission.md](../../runbooks/cab-submission.md)

---

**End of Phase 7 Prompt**
